{{#contentFor "title"}}Bindings | Code{{/contentFor}}
{{#contentFor "tabName"}}bindings{{/contentFor}}
{{!< layouts/code.html}}

<h1>Bindings</h1>

<h2 id="asyncMessage">asyncMessage</h2>
<h4>Supports Virtual Elements: NO</h4>
<p>
  Used to display notification to the end user that an action is taking place. Mainly used
  in conjunction with remote validation.
</p>
<pre>
  <code class="html">
&lt;p data-bind=&quot;asyncMessage: trueFalseObservable&quot; /&gt;
&lt;!-- with options --&gt;
&lt;p data-bind=&quot;asyncMessage: { value: trueFalseObservable }&quot; /&gt;
  </code>
</pre>
<h4>Options</h4>
<table class="table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>value</td>
      <td>observable boolean</td>
      <td>undefined</td>
      <td>should a validating message me shown</td>
    </tr>
    <tr>
      <td>validating</td>
      <td>html string | observable html string</td>
      <td>checking availability...</td>
      <td>HTML to be displayed when value is true</td>
    </tr>
    <tr>
      <td>valid</td>
      <td>html string | observable html string</td>
      <td>available</td>
      <td>HTML to be displayed when value is valid</td>
    </tr>
  </tbody>
</table>


<h2 id="fadeSlide">fadeSlide</h2>
<h4>Supports Virtual Elements: NO</h4>
<p>
  When the value is true the element will be slide down at the same time it is faded in. When the
  value is false the element is slide up and faded out.
</p>
<pre>
  <code class="html">
&lt;div data-bind=&quot;fadeSlide: trueFalseObservable&quot; /&gt;
&lt;!-- with options --&gt;
&lt;div data-bind=&quot;fadeSlide: { visible: trueFalseObservable }&quot; /&gt;
  </code>
</pre>
<h4>Options</h4>
<table class="table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>visible</td>
      <td>observable boolean</td>
      <td>false</td>
      <td>Should the element be visible</td>
    </tr>
    <tr>
      <td>duration</td>
      <td>number</td>
      <td>300</td>
      <td>number of milliseconds for the animation to complete</td>
    </tr>
    <tr>
      <td>afterAnimation</td>
      <td>function</td>
      <td>undefined</td>
      <td>Will be called after the slide fade animations completes</td>
    </tr>
  </tbody>
</table>


<h2 id="fadeVisible">fadeVisible</h2>
<h4>Supports Virtual Elements: NO</h4>
<p>
  When the value is true the element will be faded in. When the value is false the element
  faded out.
</p>
<pre>
  <code class="html">
&lt;div data-bind=&quot;fadeVisible: trueFalseObservable&quot; /&gt;
&lt;!-- with options --&gt;
&lt;div data-bind=&quot;fadeVisible: { visible: trueFalseObservable }&quot; /&gt;
  </code>
</pre>
<h4>Options</h4>
<table class="table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>visible</td>
      <td>observable boolean</td>
      <td>false</td>
      <td>Should the element be visible</td>
    </tr>
    <tr>
      <td>duration</td>
      <td>number</td>
      <td>300</td>
      <td>number of milliseconds for the animation to complete</td>
    </tr>
    <tr>
      <td>afterAnimation</td>
      <td>function</td>
      <td>undefined</td>
      <td>Will be called after the fade animation completes</td>
    </tr>
  </tbody>
</table>

<h2 id="templateSwitcher">templateSwitcher</h2>
<h4>Supports Virtual Elements: YES</h4>
<p>
  Will switch out templates based on the value, loading, and error properties. This saves you from
  having to write a bunch of if logic to pick the template you want to display. This binding is
  heavily used in the listview control
</p>
<pre>
  <code class="html">
&lt;div data-bind=&#39;templateSwitcher: { value: ArrayOrObject, loading: loadingProp, error: hasRequestErrored, templates :{ display:&quot;templateName&quot;} }&#39;&gt;&lt;/div&gt;
  </code>
</pre>
<h4>Options</h4>
<table class="table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>value</td>
      <td>any | observable any</td>
      <td>undefined</td>
      <td>value that will be passed to the display template</td>
    </tr>
    <tr>
      <td>loading</td>
      <td>boolean | observable boolean</td>
      <td>false</td>
      <td>when true the loading template is displayed</td>
    </tr>
    <tr>
      <td>error</td>
      <td>boolean | observable boolean</td>
      <td>false</td>
      <td>when true the error template is displayed</td>
    </tr>
    <tr>
      <td>templates.display</td>
      <td>string | observable string</td>
      <td>undefined</td>
      <td>will be called with value if error and loading are false</td>
    </tr>
    <tr>
      <td>templates.empty</td>
      <td>string | observable string</td>
      <td>cyclops.templateSwitcherEmptyTemplate</td>
      <td>if value is an array and it is empty this template will be called</td>
    </tr>
    <tr>
      <td>templates.loading</td>
      <td>string | observable string</td>
      <td>cyclops.templateSwitcherLoadingTemplate</td>
      <td>will be called when loading is true</td>
    </tr>
    <tr>
      <td>templates.error</td>
      <td>string | observable string</td>
      <td>cyclops.templateSwitcherErrorTemplate</td>
      <td>will be called when error is true</td>
    </tr>
  </tbody>
</table>


<h2 id="validationMsg">validationMsg</h2>
<h4>Supports Virtual Elements: NO</h4>
<p>
  Same as the knockout-validation validationMessage binding but has a nice animation when displaying
  or hiding the message.
</p>
<pre>
  <code class="html">
&lt;p data-bind=&quot;validationMsg: someValue&quot; /&gt;
  </code>
</pre>
<h4>Options</h4>
<table class="table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>value</td>
      <td>any | observable any</td>
      <td>undefined</td>
      <td>value that is being validated</td>
    </tr>
  </tbody>
</table>


<h2 id="widget">widget</h2>
<h4>Supports Virtual Elements: NO</h4>
<p>
  Creates jQuery widgets based on the name and options passed in.  This is relatively expensive
  so it should be used with caution but it can be very handy. Technically it doesnâ€™t have to be a
  jQuery widget just a function that hangs off a dom node but it works best when it follows the
  jQuery widget conventions.
</p>
<pre>
  <code class="html">
    &lt;input type=&quot;submit&quot; value=&quot;OK&quot; data-bind=&#39;widget: &quot;button&quot;&#39; /&gt;
    &lt;!-- with options --&gt;
    &lt;input id=&#39;search&#39; data-bind=&#39;widget: { name: &quot;autocomplete&quot;, options: { source: searchCompletions(), delay: 500 } }, value: searchString&#39; /&gt;
    &lt;!-- enable or disable --&gt;
    &lt;input id=&#39;search&#39; data-bind=&#39;widget: { name: &quot;autocomplete&quot;, disabled: trueyOrFalsey, value: searchString&#39; /&gt;
  </code>
</pre>
<h4>Options</h4>
<table class="table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>name</td>
      <td>string | observable string</td>
      <td>undefined</td>
      <td>name of the widget or function</td>
    </tr>
    <tr>
      <td>disabled</td>
      <td>boolean | observable boolean</td>
      <td>false</td>
      <td>calls the widgets disable funtion</td>
    </tr>
    <tr>
      <td>enabled</td>
      <td>boolean | observable boolean</td>
      <td>false</td>
      <td>calls the widgets disable funtion with false and wires everything back up</td>
    </tr>
    <tr>
      <td>options</td>
      <td>any | observable any</td>
      <td>empty object</td>
      <td>any options for the widget</td>
    </tr>
  </tbody>
</table>
